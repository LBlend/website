---
import { formatDistance } from "date-fns";

import cache from "@api/_cache";
import Song from "@elements/Song.astro";

export interface LastFMResponse {
  lovedtracks: Lovedtracks;
}

export interface Lovedtracks {
  track: Track[];
  "@attr": Attr;
}

export interface Attr {
  perPage: string;
  totalPages: string;
  page: string;
  total: string;
  user: string;
}

export interface Track {
  artist: Artist;
  date: DateClass;
  mbid: string;
  url: string;
  name: string;
  image: Image[];
  streamable: Streamable;
}

export interface Artist {
  url: string;
  name: string;
  mbid: string;
}

export interface DateClass {
  uts: string;
  "#text": string;
}

export interface Image {
  size: Size;
  "#text": string;
}

export enum Size {
  Extralarge = "extralarge",
  Large = "large",
  Medium = "medium",
  Small = "small",
}

export interface Streamable {
  fulltrack: string;
  "#text": string;
}

async function getLovedTracks(): Promise<LastFMResponse> {
  const cacheKey = "lastfmTracks";
  const cached = cache.get<LastFMResponse>(cacheKey);
  if (cached) return cached;

  const emptyResponse = {
    lovedtracks: {
      track: [],
      "@attr": { perPage: "0", totalPages: "0", page: "0", total: "0", user: "" },
    },
  };

  try {
    const apiKey = import.meta.env.LASTFM_API_KEY;
    if (!apiKey) {
      console.warn("LastFM API key not configured");
      return emptyResponse;
    }

    const params = new URLSearchParams({
      method: "user.getlovedtracks",
      format: "json",
      api_key: apiKey,
      user: import.meta.env.LASTFM_USERNAME,
      limit: "1000",
    });

    // Add timeout to the fetch request
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000); // 5 second timeout

    const res = await fetch(`${import.meta.env.LASTFM_URL}?` + params, {
      method: "GET",
      cache: "force-cache",
      signal: controller.signal,
    });

    clearTimeout(timeoutId);

    if (!res.ok) {
      console.warn("Failed to fetch loved tracks", res.status, res.statusText);
      return emptyResponse;
    }

    const data = await res.json();

    // Cache for 10 minutes
    cache.set(cacheKey, data, 10 * 60 * 1000);
    return data;
  } catch (error) {
    console.warn("LastFM API error:", error);
    return emptyResponse;
  }
}

const data = await getLovedTracks();

const groupedTracks = data.lovedtracks.track.reduce((acc: Record<string, Track[]>, track: Track) => {
  const date = new Date(Number(track.date.uts) * 1000);
  const distance = formatDistance(date, new Date(), { addSuffix: true });

  if (!acc[distance]) {
    acc[distance] = [];
  }

  acc[distance].push(track);

  return acc;
}, {});
---

<div class="flex w-full flex-col gap-8 p-6">
  <h3 class="text-center text-4xl font-bold lg:text-left lg:text-2xl">Recently liked songs</h3>
  <div class="flex flex-col gap-8">
    {
      groupedTracks && Object.keys(groupedTracks).length === 0 && (
        <p class="text-center text-gray-500">Failed fetching songs</p>
      )
    }
    {
      Object.entries(groupedTracks).map(([time, tracks]) => (
        <div class="flex flex-col gap-4">
          <h2 class="border-b border-gray-700 text-center font-semibold">{time}</h2>
          <div class="flex flex-col gap-6">
            {tracks.map((track: Track) => (
              <Song track={track} />
            ))}
          </div>
        </div>
      ))
    }
  </div>
</div>
