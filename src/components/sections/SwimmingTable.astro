---
import { useTranslations } from "@i18n/index";

const { data } = Astro.props;

const locale = Astro.locals.locale;
const t = useTranslations(locale);

const i18nData = JSON.stringify({
  distance: t("swimming.distance"),
  stroke: t("swimming.stroke"),
  time: t("swimming.time"),
  date: t("swimming.date"),
  city: t("swimming.city"),
  country: t("swimming.country"),
  poolLength: t("swimming.poolLength"),
  partialDistance: t("swimming.partialDistance"),
  yes: t("swimming.yes"),
});
---

<div>
  <div class="flex flex-col">
    <label>
      <input type="checkbox" id="bestTimesToggle" checked />
      <span>{t("swimming.onlyBestTimes")}</span>
    </label>
    <label>
      <input type="checkbox" id="showPartialsToggle" checked />
      <span>{t("swimming.showPartials")}</span>
    </label>
  </div>

  <div class="overflow-x-auto">
    <div id="wrapper" class="text-xs sm:text-sm md:text-base" data-i18n={i18nData}></div>
  </div>
</div>

<link href="https://unpkg.com/gridjs/dist/theme/mermaid.min.css" rel="stylesheet" />
<script src="https://unpkg.com/gridjs/dist/gridjs.umd.js"></script>

<script define:vars={{ data }}>
  function initTable() {
    if (typeof window.gridjs === "undefined") {
      setTimeout(initTable, 100);
      return;
    }

    const { Grid } = window.gridjs;
    let gridInstance = null;

    const wrapper = document.getElementById("wrapper");
    const i18n = JSON.parse(wrapper?.dataset.i18n || "{}");

    function formatTime(seconds) {
      const totalSeconds = parseFloat(seconds);
      const minutes = Math.floor(totalSeconds / 60);
      const remainingSeconds = totalSeconds % 60;

      if (minutes > 0) {
        return `${minutes}:${remainingSeconds.toFixed(2).padStart(5, "0")}`;
      }

      return remainingSeconds.toFixed(2);
    }

    // Convert to data types
    const processedData = data.map((row) => [
      parseFloat(row[0]), // Distance
      row[1], // Stroke
      parseFloat(row[2]), // Time (keep as number for sorting)
      row[3], // Date
      row[4], // City
      row[5], // Country
      parseInt(row[6]), // Pool Length
      parseInt(row[7]), // IsPartialDistance (0 or 1)
    ]);

    function filterPartials(data, showPartials) {
      if (showPartials) return data;
      return data.filter((row) => row[7] === 0);
    }

    function getBestTimes(data) {
      const bestTimes = {};

      data.forEach((row) => {
        const distance = row[0];
        const stroke = row[1];
        const time = row[2];
        const key = `${distance}-${stroke}`;

        if (!bestTimes[key] || time < bestTimes[key].time) {
          bestTimes[key] = {
            time: time,
            row: row,
          };
        }
      });

      return Object.values(bestTimes).map((item) => item.row);
    }

    function createGrid(showBestOnly = true, showPartials = true) {
      let dataToShow = processedData;

      dataToShow = filterPartials(dataToShow, showPartials);
      if (showBestOnly) {
        dataToShow = getBestTimes(dataToShow);
      }

      const columns = [
        {
          name: i18n.distance || "Distance",
          formatter: (cell) => `${cell}m`,
        },
        i18n.stroke || "Stroke",
        {
          name: i18n.time || "Time",
          formatter: (cell) => formatTime(cell),
        },
        i18n.date || "Date",
        i18n.city || "City",
        i18n.country || "Country",
        {
          name: i18n.poolLength || "Pool Length",
          formatter: (cell) => `${cell}m`,
        },
      ];

      // Only add Partial Distance column if showing partials
      if (showPartials) {
        columns.push({
          name: i18n.partialDistance || "Partial Distance?",
          formatter: (cell) => (cell === 1 ? i18n.yes || "Yes" : ""),
        });
      }
      // Adjust data to match columns
      const adjustedData = showPartials ? dataToShow : dataToShow.map((row) => row.slice(0, 7)); // Remove last column (Partial Distance)

      // Destroy existing grid if it exists
      if (gridInstance) {
        gridInstance.destroy();
      }

      gridInstance = new Grid({
        columns: columns,
        data: adjustedData,
        sort: true,
        search: true,
        pagination: { enabled: true, limit: 20 },
        search: {
          enabled: true,
        },
      });

      gridInstance.render(document.getElementById("wrapper"));
    }

    // Initial render
    createGrid(true, true);

    const bestTimesToggle = document.getElementById("bestTimesToggle");
    const showPartialsToggle = document.getElementById("showPartialsToggle");
    function updateGrid() {
      createGrid(bestTimesToggle.checked, showPartialsToggle.checked);
    }
    bestTimesToggle.addEventListener("change", updateGrid);
    showPartialsToggle.addEventListener("change", updateGrid);
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", initTable);
  } else {
    initTable();
  }
</script>
